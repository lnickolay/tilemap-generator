"""Receives WFC worker updates and emits the corresponding PyQt signals."""

from __future__ import annotations

from typing import TYPE_CHECKING

import numpy as np
from PyQt6 import QtCore as qtc

from enums import WFCUpdateType

if TYPE_CHECKING:
    from multiprocessing import Queue
    from multiprocessing.synchronize import Event as EventType


class WFCUpdateListener(qtc.QObject):
    """Listens to WFC worker processes and emits Qt signals for UI updates.

    This class runs in a separate QThread, continuously retrieving messages from the Queue that were generated by the
    worker processes. It translates these messages into PyQt signals, which can safely be connected to update functions
    in the main GUI thread. It is designed to pause (wait) after processing an update to synchronize the GUI with the
    rendering process and to avoid freezing the GUI if updates from the worker processes come very often (this is the
    case with WFCUpdateType.OUTPUT_CELL_COLLAPSED).

    Signals:
        segment_finished: Emitted whenever a full segment is collapsed.
        finished: Emitted when the entire biome generation is complete.
        output_cell_collapsed: Emitted whenever a single cell is collapsed.
    """

    segment_finished = qtc.pyqtSignal(np.ndarray, tuple, int)
    finished = qtc.pyqtSignal(np.ndarray, int)
    output_cell_collapsed = qtc.pyqtSignal(tuple, int)

    # The multiprocessing queue receiving messages from the WFC worker processes.
    _update_queue: Queue
    # The condition used to pause the listener, waiting for a wake-up call to resume.
    _wait_cond: qtc.QWaitCondition
    # The event set by the main process to signal an immediate stop.
    _abort_event: EventType

    # The mutex used in conjunction with the QWaitCondition.
    _mutex: qtc.QMutex

    def __init__(self, update_queue: Queue, wait_cond: qtc.QWaitCondition, abort_event: EventType) -> None:
        """Initializes the listener with communication/synchronization objects.

        Args:
            update_queue: The multiprocessing queue receiving messages from the WFC worker processes.
            wait_cond: The condition used to pause the listener, waiting for a wake-up call to resume.
            abort_event: The event set by the main process to signal an immediate stop.
        """
        super().__init__()

        self._update_queue = update_queue
        self._wait_cond = wait_cond
        self._abort_event = abort_event

        self._mutex = qtc.QMutex()

    def run(self) -> None:
        """The main loop for retrieving messages and emitting Qt signals.

        This method is typically executed inside a separate QThread. It runs until the global abort event is set.
        """
        while not self._abort_event.is_set():
            message = self._update_queue.get()
            match message[0]:
                case WFCUpdateType.SEGMENT_FINISHED:
                    # Emits: tilemap_segment, segment_offset, biome_index.
                    self.segment_finished.emit(message[1], message[2], message[3])
                case WFCUpdateType.FINISHED:
                    # Emits: tilemap, biome_index.
                    self.finished.emit(message[1], message[2])
                case WFCUpdateType.OUTPUT_CELL_COLLAPSED:
                    # Emits: absolute_coords, tile_index.
                    self.output_cell_collapsed.emit(message[1], message[2])

            self._mutex.lock()
            # Blocks the thread, waiting for the GUI to finish rendering the update.
            self._wait_cond.wait(self._mutex)
            self._mutex.unlock()
